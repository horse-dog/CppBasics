#### ***const char \**** 与 ***char \* const***

- *const char \**：等价于 char const *，指向字符串常量	==> (char const) *：const 修饰的是 char
- *char \* const*：指向字符串，指针本身为常指针               ==> (char *) const：const 修饰的是 char *

#### 类型转换

- *static_cast*：编译期内即可决定其类型的转换。不能转换掉底层的const、volatile和__unaligned属性。
- *dynamic_cast*：仅适用于指针或引用。用于多态中父子类之间的多态转换，会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。
- *const_cast*：仅适用于指针或引用。用于移除类型的const、volatile和__unaligned属性。
- *reinterpret_cast*：非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

#### 自动初始化

- 全局变量和静态变量如果没有显示地初始化，会自动进行初始化，存储在 `bss` 段。
  - 如果是基础类型，默认填充为全0。
  - 如果是类对象，调用默认构造函数。

- 局部变量如果没有显示地初始化：
  - 如果是基础类型，不会自动初始化，可能是任意值。
  - 如果是类对象，调用默认构造函数。

- 数组的初始化：
  - 全局或静态的数组：基础类型填充为全0，类类型调用默认构造。
  - 局部数组：基础类型不会自动初始化，可能是任意值，类类型调用默认构造函数。

- new 数组的初始化：
  - 基础类型不会自动初始化，可能是任意值。
  - 类类型调用默认构造函数。

- 类成员的初始化：
  - 基础类型类成员不会自动初始化，可能为任意值。
  - 类类型成员自动调用默认构造函数初始化。

#### 初始化方式

- 对于变量：可以使用 `{}` 或 `()` 初始化，括号内可以填充构造函数的参数，不填则调用默认构造。`()` 允许不安全的类型转换，`{}` 则不允许。还可以在 `{}` 前面加上 `=`，此时转变为调用移动构造函数。`()` 前面不能加 `=`。

- 对于数组：使用 `{}` 初始化，前面可以有 `=`，`{}` 内可以填充部分值，剩下的值会调用默认构造函数初始化（基础类型填全0）。

- 对于 `new` 数组：普通与数组一致。

#### 操作符重载

- 类成员函数重载单目操作符
  - 重载形式为：*<Return_type> operator <?> (<Input_type> input)*，调用形式为：*a.operator ? (intput)*
  - 例如：*T &operator\[](size_t index)*：调用形式为：*a[0]*
- 类成员函数重载双目操作符
  - 重载形式为：*<Return_type> operator <?> (<Type_right> right)*，调用形式为：*left <?> right*
  - 例如：*bool operator=(const T &right)*：调用形式为 *left = right*
- 友元函数重载单目操作符
  - 重载形式为：*friend <Return_type> operator<?>(<Input_type> input)*，调用形式为：*<?>(a)*
  - 例如：*friend void print_item(const T &item)*，调用形式为：*print_item(a)*
- 友元函数重载双目操作符
  - 因为 *cout << a* 的调用者为 *cout* 对象，而不是要输出的对象本身，因而不能使用成员函数重载，需要使用友元函数重载
  - 重载形式为：*friend  <Return_type> operator <?> (<Type_left> & left, <Type_right> &*right)，调用形式为：*left <?> right*
  - 例如：*friend ostream &operator<<(ostream &os, const T &right)*，调用形式为：*cout << right*

#### 什么是多态

- 多态就是不同对象对同一行为会有不同的状态。
- 当父类指针指向子类对象,然后通过父类指针能调用子类的成员函数。

#### 什么是虚函数

- 虚函数是带有 ***virtual*** 关键字的成员函数。

#### 多态的原理

- 多态是用虚函数表实现的。
- 有虚函数的类都会生成一个虚函数表，这个表在编译时生成。
- 虚函数表是一个存储虚函数地址的数组,以 ***NULL*** 结尾。
- 如果要生成子类虚表,就要经过三个步骤：
  - 第一步，将父类虚表内容拷贝到子类虚表上；
  - 第二步，将子类重写的虚函数覆盖掉表中父类的虚函数；
  - 第三步，如果子类有新增加的虚函数,按声明次序加到最后；

#### 静态多态与动态多态

- 静态多态：函数重载或模板实现，编译时确定。
- 动态多态：虚函数，父类指向子类对象实现，运行时确定。

#### ***inline*** 函数可以是虚函数吗

- 不能，因为 ***inline*** 函数没有地址,无法放到虚函数表中。

#### 静态成员可以是虚函数吗

- 不能, 因为静态成员函数没有this指针, 因为有 *this* 指针才能访问到虚表指针,有虚表指针才能找到虚表从而调用实际应该调用的函数。

#### 构造函数可以是虚函数吗?/虚函数指针在什么时候生成的

- 不能,因为对象中的虚表指针是在构造函数初始化列表阶段才初始化的。

#### 析构函数可以是虚函数吗?什么场景下析构函数是虚函数

- 可以,并且最好把基类的析构函数定义成虚函数

#### 对象访问普通函数快还是虚函数更快

- 如果是普通对象，是一样快的。
- 如果是指针对象或引用对象,则调用的普通函数快，因为普通对象在编译时就确定地址了，虚函数构成多态，运行时调用虚函数需要到虚函数表中去查找。

#### 虚函数表是在什么阶段生成的，存在哪里

- 虚函数是在编译阶段就生成的，虚函数和普通函数一样在代码段，虚表在只读常量区。

#### ***static*** 关键字

- 静态全局变量。

- 静态局部变量。

- 静态函数：只能在声明它的文件当中可见，不能被其它文件使用。

- 静态数据成员。

- 静态成员函数。

#### ***volatile*** 关键字

- 直接存取原始内存地址
- 如果没有 *volatile* 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。
- 频繁地使用 *volatile* 很可能会增加代码尺寸和降低性能,因此要合理的使用 *volatile*。

#### ***restrict*** 关键字

- *restrict* 关键字用于修饰指针(C99标准)
- 加上 *restrict* 关键字，编程者可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用

#### ***mutable*** 关键字

- 被 *const* 修饰的成员函数无法修改类的成员变量
- 需要在 *const* 成员函数中修改成员变量的值
- 用 *mutable* 关键字修饰想要修改成员变量

#### 引用的底层

- 对象的指针
- 引用初始化后不可变
- *sizeof* 引用和 *sizeof* 指针的区别：*sizeof* 引用：对象的字节数，*sizeof* 指针：8（64位系统）
- 指针和引用占用内存空间吗？：当然占用

#### ***hashmap*** 底层

- *hash* 函数
- 模运算
- *hash* 冲突与 *hash* 桶
- 负载因子与扩容
- 链表与红黑树

#### 进程与线程的区别

- 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
- 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

#### 进程间通信

- 管道：速度慢，容量有限，只有父子进程能通讯
- ***FIFO***：任何进程间都能通讯，但速度慢
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全
